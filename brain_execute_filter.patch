--- a/index.js
+++ b/index.js
@@ -16,6 +16,9 @@ import fs from 'fs';
 import path from 'path';
 
+// Import OutputFilter for context window management
+import { OutputFilter } from '../mcp-shared-utils/index.js';
+
 // Debug logging
 const DEBUG_LOG_FILE = '/tmp/mcp_debug.log';
 
@@ -399,6 +402,9 @@ const tools = [
         language: { 
           type: 'string', 
           enum: ['python', 'shell', 'auto'], 
           default: 'auto' 
         },
-        description: { type: 'string', description: 'What this code does' }
+        description: { type: 'string', description: 'What this code does' },
+        verbose: { 
+          type: 'boolean', 
+          description: 'Return full output without filtering',
+          default: false
+        }
       },
       required: ['code']
     },
-    handler: async ({ code, language = 'auto', description }) => {
+    handler: async ({ code, language = 'auto', description, verbose = false }) => {
       let execId, logEntry, startTime;
       try {
+        // Initialize output filter
+        const filter = new OutputFilter({ 
+          verbose: verbose,
+          maxLines: 50,
+          maxChars: 5000
+        });
+        
         // Detect language
         if (language === 'auto') {
           language = code.includes('import ') || code.includes('def ') || code.includes('print(') 
             ? 'python' 
             : 'shell';
         }
         
         // Create execution log
         const logResult = createExecutionLog(code, language, description);
         execId = logResult.execId;
         logEntry = logResult.logEntry;
         
         let output = '';
+        let rawOutput = '';
         startTime = Date.now();
         
         if (language === 'python') {
           output += `üêç Executing python code: ${description || 'No description provided'}\\n`;
           
           const { stdout, stderr } = await execAsync(
             `python3 -c '${code.replace(/'/g, "'\"'\"'")}'`,
             { maxBuffer: 10 * 1024 * 1024 }
           );
           
-          if (stdout) output += `üì§ Output:${stdout}`;
-          if (stderr) output += `‚ö†Ô∏è Errors:${stderr}`;
+          rawOutput = stdout || '';
+          if (stderr) rawOutput += `\\n‚ö†Ô∏è Errors:\\n${stderr}`;
           
         } else {
           output += `üñ•Ô∏è Executing shell command: ${description || 'No description provided'}\\n`;
           
           const { stdout, stderr } = await execAsync(code, {
             shell: true,
             maxBuffer: 10 * 1024 * 1024
           });
           
-          if (stdout) output += `üì§ Output:\\n${stdout}`;
-          if (stderr) output += `‚ö†Ô∏è Errors:\\n${stderr}`;
+          rawOutput = stdout || '';
+          if (stderr) rawOutput += `\\n‚ö†Ô∏è Errors:\\n${stderr}`;
         }
         
+        // Detect command type for better filtering
+        const commandType = detectCommandType(code);
+        
+        // Filter output
+        const filtered = filter.filter(rawOutput, commandType);
+        
+        if (filtered.metadata.filtered) {
+          output += `üì§ Output (filtered):\\n${filtered.result}`;
+          
+          // Add metadata about filtering
+          if (filtered.metadata.truncated) {
+            output += `\\n\\nüìä Filtering info:\\n`;
+            output += `  ‚Ä¢ Original: ${filtered.metadata.originalLines} lines, ${filtered.metadata.originalSize}\\n`;
+            output += `  ‚Ä¢ Displayed: ${filtered.metadata.displayedLines || filtered.metadata.displayedChars} ${filtered.metadata.truncatedAt === 'lines' ? 'lines' : 'chars'}\\n`;
+            if (filtered.metadata.gitStats) {
+              output += `  ‚Ä¢ Git stats: ${filtered.metadata.summary}\\n`;
+            }
+            output += `  ‚Ä¢ Use verbose: true for full output`;
+          }
+        } else {
+          output += `üì§ Output:\\n${filtered.result}`;
+        }
+        
         const executionTime = Date.now() - startTime;
-        output += `‚è±Ô∏è Execution time: ${executionTime}ms`;
+        output += `\\n‚è±Ô∏è Execution time: ${executionTime}ms`;
         
         // Save execution log
         if (execId && logEntry) {
           logEntry.status = 'completed';
-          logEntry.output = output;
+          logEntry.output = rawOutput; // Store full output in log
           logEntry.execution_time = executionTime / 1000;
           saveExecutionLog(execId, logEntry);
         }
         
         return { content: [{ type: 'text', text: output }] };